<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Mastermind 3D Simplifié</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; color: white; font-family: sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            max-width: 300px;
        }
        #tentative-input { margin-top: 10px; }
    </style>
</head>
<body>

    <div id="info">
        <h3>Mastermind 3D Simplifié</h3>
        <p>Objectif : Trouver la combinaison secrète (4 couleurs).</p>
        <p>Couleurs disponibles : Rouge (R), Vert (G), Bleu (B), Jaune (Y), Blanc (W), Noir (K).</p>
        <p>Exemple de tentative : RGYB</p>
        <div id="tentative-input">
            <input type="text" id="guess" maxlength="4" placeholder="Entrez 4 lettres (RGW...)">
            <button onclick="makeGuess()">Soumettre</button>
        </div>
        <p>Historique des coups :</p>
        <ul id="history"></ul>
        <p id="message"></p>
    </div>

    <script>
        // --- LOGIQUE MASTERMIND (JavaScript) ---

        const COLORS = ['R', 'G', 'B', 'Y', 'W', 'K']; // Rouge, Vert, Bleu, Jaune, Blanc, Noir
        const SECRET_CODE = generateSecretCode();
        const MAX_ATTEMPTS = 10;
        let attempts = 0;

        function generateSecretCode() {
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += COLORS[Math.floor(Math.random() * COLORS.length)];
            }
            console.log('Code secret (pour le debug) :', code);
            return code;
        }

        function checkGuess(guess) {
            let correctColorAndPosition = 0;
            let correctColorOnly = 0;

            const secret_copy = SECRET_CODE.split('');
            const guess_copy = guess.split('');

            // 1. Vérifier les positions correctes (Pions Noirs)
            for (let i = 0; i < 4; i++) {
                if (guess_copy[i] === secret_copy[i]) {
                    correctColorAndPosition++;
                    // Marquer comme utilisé
                    guess_copy[i] = null; 
                    secret_copy[i] = null;
                }
            }

            // Filtrer les nulls pour le prochain contrôle
            const filtered_secret = secret_copy.filter(c => c !== null);
            const filtered_guess = guess_copy.filter(c => c !== null);

            // 2. Vérifier les couleurs correctes (Pions Blancs)
            for (let i = 0; i < filtered_guess.length; i++) {
                const index = filtered_secret.indexOf(filtered_guess[i]);
                if (index !== -1) {
                    correctColorOnly++;
                    // Marquer comme utilisé dans le secret
                    filtered_secret[index] = null; 
                }
            }

            return { black: correctColorAndPosition, white: correctColorOnly };
        }

        function makeGuess() {
            if (attempts >= MAX_ATTEMPTS) {
                document.getElementById('message').textContent = "Game Over ! Vous n'avez plus d'essais.";
                return;
            }

            const guessElement = document.getElementById('guess');
            const guess = guessElement.value.toUpperCase();
            
            if (guess.length !== 4 || !guess.split('').every(c => COLORS.includes(c))) {
                document.getElementById('message').textContent = "Format invalide. Utilisez 4 lettres parmi R, G, B, Y, W, K.";
                return;
            }

            attempts++;
            const result = checkGuess(guess);
            
            // Afficher le résultat
            const historyList = document.getElementById('history');
            const listItem = document.createElement('li');
            listItem.textContent = `Essai ${attempts} (${guess}) : ${result.black} Bonnes couleurs/positions (Pions Noirs), ${result.white} Bonnes couleurs (Pions Blancs).`;
            historyList.appendChild(listItem);

            // Mettre à jour la scène 3D (voir plus bas)
            update3DScene(guess, result.black, result.white);

            // Vérifier la victoire
            if (result.black === 4) {
                document.getElementById('message').textContent = `Victoire ! Vous avez trouvé le code secret (${SECRET_CODE}) en ${attempts} coups.`;
                document.getElementById('tentative-input').style.display = 'none';
            } else if (attempts >= MAX_ATTEMPTS) {
                document.getElementById('message').textContent = `Game Over ! Le code secret était ${SECRET_CODE}.`;
                document.getElementById('tentative-input').style.display = 'none';
            }
            
            guessElement.value = ''; // Réinitialiser le champ
        }


        // --- RENDU 3D (Three.js) ---

        let scene, camera, renderer;
        const colorMap = {
            'R': 0xff0000, 'G': 0x00ff00, 'B': 0x0000ff, 
            'Y': 0xffff00, 'W': 0xffffff, 'K': 0x000000
        };

        function init3D() {
            // Scène et Caméra
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // Rendu
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lumières
            const ambientLight = new THREE.AmbientLight(0x404040, 5); // soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            // Sol (optionnel)
            const planeGeometry = new THREE.PlaneGeometry(20, 20);
            const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x555555, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            scene.add(plane);
            
            // Premier rendu pour afficher l'environnement
            renderer.render(scene, camera);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function createPeg(colorCode, x, y, z) {
            const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 32);
            const material = new THREE.MeshPhongMaterial({ color: colorMap[colorCode] });
            const peg = new THREE.Mesh(geometry, material);
            peg.position.set(x, y, z);
            scene.add(peg);
        }

        function createFeedbackPeg(color, x, y, z) {
            const geometry = new THREE.SphereGeometry(0.2, 16, 16);
            const material = new THREE.MeshPhongMaterial({ color: color });
            const peg = new THREE.Mesh(geometry, material);
            peg.position.set(x, y, z);
            scene.add(peg);
        }

        function update3DScene(guess, blackPegs, whitePegs) {
            const zPosition = attempts * -2; // Chaque essai est placé plus loin (dans le négatif)
            const xOffset = -3;
            const yPosition = 0.75; // Demi-hauteur du pion

            // 1. Dessiner les 4 pions de la tentative (couleurs)
            for (let i = 0; i < 4; i++) {
                createPeg(guess[i], xOffset + (i * 1.5), yPosition, zPosition);
            }

            // 2. Dessiner les pions de feedback (noir et blanc)
            let feedbackCount = 0;
            const feedbackX = xOffset + 6;
            const feedbackY = 1.2; // Légèrement plus haut pour les pions de feedback

            // Pions noirs (bonne couleur, bonne position)
            for (let i = 0; i < blackPegs; i++) {
                createFeedbackPeg(0x000000, feedbackX + (feedbackCount * 0.5) - 0.5, feedbackY, zPosition);
                feedbackCount++;
            }

            // Pions blancs (bonne couleur, mauvaise position)
            for (let i = 0; i < whitePegs; i++) {
                createFeedbackPeg(0xffffff, feedbackX + (feedbackCount * 0.5) - 0.5, feedbackY, zPosition);
                feedbackCount++;
            }

            // Déplacer la caméra pour suivre la dernière tentative
            camera.position.z = zPosition + 10;
            camera.position.y = 5;
            camera.lookAt(0, 0, zPosition);
            
            renderer.render(scene, camera);
        }

        // Initialiser la scène 3D au chargement de la page
        init3D();
    </script>
</body>
</html>